
package frc.robot.subsystems.choreo;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import java.util.Map;
import java.util.OptionalInt;

// If these imports cause errors because you're not using ChoreoLib,
// turn off "Include ChoreoLib-specific Helpers" in Choreo's codegen settings.
import choreo.auto.AutoRoutine;
import choreo.auto.AutoTrajectory;

/**
 * A class containing the name, start pose, end pose, and total time of every Choreo trajectory.
 * This prevents your code from referencing deleted or misspelled trajectories,
 * and removes the need for JSON parsing to load a trajectory's essential data.
 * DO NOT MODIFY THIS FILE YOURSELF! It is automatically generated by Choreo.
 */
public record ChoreoTraj(
    String name,
    OptionalInt segment,
    double totalTimeSecs,
    Pose2d initialPoseBlue,
    Pose2d endPoseBlue
) {
    public static final ChoreoTraj Right_Trench_Neutral1 = new ChoreoTraj(
	    "Right_Trench_Neutral1",
	    OptionalInt.empty(),
	    2.16816,
	    new Pose2d(12.169, 7.406, Rotation2d.fromRadians(3.142)),
	    new Pose2d(8.777, 5.204, Rotation2d.fromRadians(-1.571))
	);
	public static final ChoreoTraj Climb_Left_Front = new ChoreoTraj(
	    "Climb_Left_Front",
	    OptionalInt.empty(),
	    0.61265,
	    new Pose2d(14.858, 3.43, Rotation2d.fromRadians(-0.197)),
	    new Pose2d(14.936, 3.84, Rotation2d.fromRadians(3.142))
	);
	public static final ChoreoTraj Left_Trench_Shoot2 = new ChoreoTraj(
	    "Left_Trench_Shoot2",
	    OptionalInt.empty(),
	    2.48601,
	    new Pose2d(8.66, 3.528, Rotation2d.fromRadians(1.571)),
	    new Pose2d(14.858, 3.43, Rotation2d.fromRadians(-0.197))
	);
	public static final ChoreoTraj Right_Trench_Shoot1 = new ChoreoTraj(
	    "Right_Trench_Shoot1",
	    OptionalInt.empty(),
	    1.70288,
	    new Pose2d(8.777, 5.204, Rotation2d.fromRadians(-1.571)),
	    new Pose2d(13.007, 7.484, Rotation2d.fromRadians(1.267))
	);
	public static final ChoreoTraj Left_Trench_Neutral2 = new ChoreoTraj(
	    "Left_Trench_Neutral2",
	    OptionalInt.empty(),
	    2.49672,
	    new Pose2d(13.026, 0.76, Rotation2d.fromRadians(-1.297)),
	    new Pose2d(8.66, 3.528, Rotation2d.fromRadians(1.571))
	);
	public static final ChoreoTraj Left_Depot = new ChoreoTraj(
	    "Left_Depot",
	    OptionalInt.empty(),
	    0.57047,
	    new Pose2d(15.156, 2.051, Rotation2d.fromRadians(-0.6)),
	    new Pose2d(15.862, 2.1, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj Right_Trench_Outpost = new ChoreoTraj(
	    "Right_Trench_Outpost",
	    OptionalInt.empty(),
	    2.52429,
	    new Pose2d(8.699, 4.658, Rotation2d.fromRadians(-1.571)),
	    new Pose2d(15.658, 7.378, Rotation2d.fromRadians(0.835))
	);
	public static final ChoreoTraj Left_Trench_Neutral1 = new ChoreoTraj(
	    "Left_Trench_Neutral1",
	    OptionalInt.empty(),
	    2.09841,
	    new Pose2d(12.11, 0.604, Rotation2d.fromRadians(3.142)),
	    new Pose2d(8.719, 2.631, Rotation2d.fromRadians(1.571))
	);
	public static final ChoreoTraj Climb_Right_Front = new ChoreoTraj(
	    "Climb_Right_Front",
	    OptionalInt.empty(),
	    0.54991,
	    new Pose2d(14.8, 4.756, Rotation2d.fromRadians(0.245)),
	    new Pose2d(14.897, 4.639, Rotation2d.fromRadians(3.142))
	);
	public static final ChoreoTraj Left_Trench_Depot = new ChoreoTraj(
	    "Left_Trench_Depot",
	    OptionalInt.empty(),
	    2.34126,
	    new Pose2d(8.66, 3.528, Rotation2d.fromRadians(1.571)),
	    new Pose2d(15.156, 2.051, Rotation2d.fromRadians(-0.6))
	);
	public static final ChoreoTraj Right_Outpost = new ChoreoTraj(
	    "Right_Outpost",
	    OptionalInt.empty(),
	    0.48932,
	    new Pose2d(15.658, 7.378, Rotation2d.fromRadians(0.835)),
	    new Pose2d(16.131, 7.402, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj Right_Trench_Shoot2 = new ChoreoTraj(
	    "Right_Trench_Shoot2",
	    OptionalInt.empty(),
	    2.53527,
	    new Pose2d(8.699, 4.658, Rotation2d.fromRadians(-1.571)),
	    new Pose2d(14.8, 4.756, Rotation2d.fromRadians(0.245))
	);
	public static final ChoreoTraj Left_Trench_Shoot1 = new ChoreoTraj(
	    "Left_Trench_Shoot1",
	    OptionalInt.empty(),
	    1.64811,
	    new Pose2d(8.719, 2.631, Rotation2d.fromRadians(1.571)),
	    new Pose2d(13.026, 0.76, Rotation2d.fromRadians(-1.297))
	);
	public static final ChoreoTraj Right_Trench_Neutral2 = new ChoreoTraj(
	    "Right_Trench_Neutral2",
	    OptionalInt.empty(),
	    2.47305,
	    new Pose2d(13.007, 7.484, Rotation2d.fromRadians(1.267)),
	    new Pose2d(8.699, 4.658, Rotation2d.fromRadians(-1.571))
	);
	public static final ChoreoTraj Mid_Depot = new ChoreoTraj(
	    "Mid_Depot",
	    OptionalInt.empty(),
	    1.23424,
	    new Pose2d(12.938, 3.996, Rotation2d.fromRadians(0)),
	    new Pose2d(15.634, 2.104, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj Mid_Outpost = new ChoreoTraj(
	    "Mid_Outpost",
	    OptionalInt.empty(),
	    1.52121,
	    new Pose2d(12.962, 3.996, Rotation2d.fromRadians(0)),
	    new Pose2d(16.131, 7.402, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj Climb_Right_Side = new ChoreoTraj(
	    "Climb_Right_Side",
	    OptionalInt.empty(),
	    0.8158,
	    new Pose2d(14.8, 4.756, Rotation2d.fromRadians(0.245)),
	    new Pose2d(15.492, 5.344, Rotation2d.fromRadians(1.571))
	);
	public static final ChoreoTraj Climb_Left_Side = new ChoreoTraj(
	    "Climb_Left_Side",
	    OptionalInt.empty(),
	    0.64811,
	    new Pose2d(14.858, 3.43, Rotation2d.fromRadians(-0.197)),
	    new Pose2d(15.516, 3.287, Rotation2d.fromRadians(-1.571))
	);
	public static final ChoreoTraj Teleop_Trench = new ChoreoTraj(
	    "Teleop_Trench",
	    OptionalInt.empty(),
	    1.05982,
	    new Pose2d(13.222, 0.614, Rotation2d.fromRadians(3.142)),
	    new Pose2d(10.692, 0.638, Rotation2d.fromRadians(3.142))
	);

    /**
     * A map between trajectory names and their corresponding data.
     * This allows for trajectory data to be looked up with strings during runtime.
     */
    public static final Map<String, ChoreoTraj> ALL_TRAJECTORIES = Map.ofEntries(
    	Map.entry("Right_Trench_Neutral1", Right_Trench_Neutral1),
		Map.entry("Climb_Left_Front", Climb_Left_Front),
		Map.entry("Left_Trench_Shoot2", Left_Trench_Shoot2),
		Map.entry("Right_Trench_Shoot1", Right_Trench_Shoot1),
		Map.entry("Left_Trench_Neutral2", Left_Trench_Neutral2),
		Map.entry("Left_Depot", Left_Depot),
		Map.entry("Right_Trench_Outpost", Right_Trench_Outpost),
		Map.entry("Left_Trench_Neutral1", Left_Trench_Neutral1),
		Map.entry("Climb_Right_Front", Climb_Right_Front),
		Map.entry("Left_Trench_Depot", Left_Trench_Depot),
		Map.entry("Right_Outpost", Right_Outpost),
		Map.entry("Right_Trench_Shoot2", Right_Trench_Shoot2),
		Map.entry("Left_Trench_Shoot1", Left_Trench_Shoot1),
		Map.entry("Right_Trench_Neutral2", Right_Trench_Neutral2),
		Map.entry("Mid_Depot", Mid_Depot),
		Map.entry("Mid_Outpost", Mid_Outpost),
		Map.entry("Climb_Right_Side", Climb_Right_Side),
		Map.entry("Climb_Left_Side", Climb_Left_Side),
		Map.entry("Teleop_Trench", Teleop_Trench)
    );

    /**
     * Looks up the ChoreoTraj segment of the given overall ChoreoTraj.
     * WARNING: will raise an exception if not called with a valid segment index.
     */
    public ChoreoTraj segment(int segment) {
        var traj = ChoreoTraj.ALL_TRAJECTORIES.get(this.name + "$" + segment);
        if (traj == null) {
            throw new NullPointerException("Trajectory " + this.name + " does not have segment #" + segment + ".");
        }
        return traj;
    }
    
    // If these methods cause errors because you're not using ChoreoLib,
    // turn off "Include ChoreoLib-specific Helpers" in Choreo's codegen settings.
    /**
     * Load an AutoTrajectory directly from a ChoreoTraj, which may be a segment of a larger trajectory.
     */
    public AutoTrajectory asAutoTraj(AutoRoutine routine) {
        if (this.segment.isPresent()) {
            return routine.trajectory(this.name, this.segment.getAsInt());
        }
        return routine.trajectory(this.name);
    }
}
