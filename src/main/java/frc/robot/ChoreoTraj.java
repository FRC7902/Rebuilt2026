
package frc.robot;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import java.util.Map;
import java.util.OptionalInt;

// If these imports cause errors because you're not using ChoreoLib,
// turn off "Include ChoreoLib-specific Helpers" in Choreo's codegen settings.
import choreo.auto.AutoRoutine;
import choreo.auto.AutoTrajectory;

/**
 * A class containing the name, start pose, end pose, and total time of every Choreo trajectory.
 * This prevents your code from referencing deleted or misspelled trajectories,
 * and removes the need for JSON parsing to load a trajectory's essential data.
 * DO NOT MODIFY THIS FILE YOURSELF! It is automatically generated by Choreo.
 */
public record ChoreoTraj(
    String name,
    OptionalInt segment,
    double totalTimeSecs,
    Pose2d initialPoseBlue,
    Pose2d endPoseBlue
) {
    public static final ChoreoTraj Preload_Mid = new ChoreoTraj(
	    "Preload_Mid",
	    OptionalInt.empty(),
	    1.17176,
	    new Pose2d(12.948, 4.035, Rotation2d.fromRadians(3.142)),
	    new Pose2d(15.267, 2.027, Rotation2d.fromRadians(2.617))
	);
	public static final ChoreoTraj Left_Neutral_Zone_Bump = new ChoreoTraj(
	    "Left_Neutral_Zone_Bump",
	    OptionalInt.empty(),
	    1.95105,
	    new Pose2d(15.267, 2.027, Rotation2d.fromRadians(2.617)),
	    new Pose2d(8.68, 3.664, Rotation2d.fromRadians(2.311))
	);
	public static final ChoreoTraj Right_Neutral_Zone1 = new ChoreoTraj(
	    "Right_Neutral_Zone1",
	    OptionalInt.empty(),
	    1.26094,
	    new Pose2d(12.169, 7.406, Rotation2d.fromRadians(3.142)),
	    new Pose2d(9.089, 6.14, Rotation2d.fromRadians(-2.266))
	);
	public static final ChoreoTraj Climb_Left = new ChoreoTraj(
	    "Climb_Left",
	    OptionalInt.empty(),
	    0.99791,
	    new Pose2d(13.279, 2.865, Rotation2d.fromRadians(2.443)),
	    new Pose2d(15.482, 3.177, Rotation2d.fromRadians(1.571))
	);
	public static final ChoreoTraj Preload_Left = new ChoreoTraj(
	    "Preload_Left",
	    OptionalInt.empty(),
	    1.00019,
	    new Pose2d(13.046, 2.3, Rotation2d.fromRadians(2.14)),
	    new Pose2d(15.267, 2.027, Rotation2d.fromRadians(2.617))
	);
	public static final ChoreoTraj Left_Shoot_Pos = new ChoreoTraj(
	    "Left_Shoot_Pos",
	    OptionalInt.empty(),
	    1.57807,
	    new Pose2d(8.68, 3.664, Rotation2d.fromRadians(2.311)),
	    new Pose2d(13.279, 2.865, Rotation2d.fromRadians(2.443))
	);
	public static final ChoreoTraj Right_Shoot_Pos2 = new ChoreoTraj(
	    "Right_Shoot_Pos2",
	    OptionalInt.empty(),
	    1.74379,
	    new Pose2d(8.66, 4.717, Rotation2d.fromRadians(-1.893)),
	    new Pose2d(13.007, 7.484, Rotation2d.fromRadians(-1.87))
	);
	public static final ChoreoTraj Right_Shoot_Pos1 = new ChoreoTraj(
	    "Right_Shoot_Pos1",
	    OptionalInt.empty(),
	    1.431,
	    new Pose2d(9.089, 6.14, Rotation2d.fromRadians(-2.266)),
	    new Pose2d(13.007, 7.484, Rotation2d.fromRadians(-1.87))
	);
	public static final ChoreoTraj Left_Neutral_Zone_Trench = new ChoreoTraj(
	    "Left_Neutral_Zone_Trench",
	    OptionalInt.empty(),
	    2.3236,
	    new Pose2d(15.267, 2.027, Rotation2d.fromRadians(2.617)),
	    new Pose2d(8.68, 3.664, Rotation2d.fromRadians(2.311))
	);
	public static final ChoreoTraj Right_Neutral_Zone2 = new ChoreoTraj(
	    "Right_Neutral_Zone2",
	    OptionalInt.empty(),
	    1.72477,
	    new Pose2d(13.007, 7.484, Rotation2d.fromRadians(-1.87)),
	    new Pose2d(8.66, 4.717, Rotation2d.fromRadians(-1.893))
	);
	public static final ChoreoTraj Climb_Right = new ChoreoTraj(
	    "Climb_Right",
	    OptionalInt.empty(),
	    1.19021,
	    new Pose2d(13.007, 7.484, Rotation2d.fromRadians(-1.87)),
	    new Pose2d(15.482, 5.516, Rotation2d.fromRadians(-1.571))
	);
	public static final ChoreoTraj Depot = new ChoreoTraj(
	    "Depot",
	    OptionalInt.empty(),
	    1.26128,
	    new Pose2d(15.267, 2.027, Rotation2d.fromRadians(2.617)),
	    new Pose2d(15.267, 2.027, Rotation2d.fromRadians(2.617))
	);

    /**
     * A map between trajectory names and their corresponding data.
     * This allows for trajectory data to be looked up with strings during runtime.
     */
    public static final Map<String, ChoreoTraj> ALL_TRAJECTORIES = Map.ofEntries(
    	Map.entry("Preload_Mid", Preload_Mid),
		Map.entry("Left_Neutral_Zone_Bump", Left_Neutral_Zone_Bump),
		Map.entry("Right_Neutral_Zone1", Right_Neutral_Zone1),
		Map.entry("Climb_Left", Climb_Left),
		Map.entry("Preload_Left", Preload_Left),
		Map.entry("Left_Shoot_Pos", Left_Shoot_Pos),
		Map.entry("Right_Shoot_Pos2", Right_Shoot_Pos2),
		Map.entry("Right_Shoot_Pos1", Right_Shoot_Pos1),
		Map.entry("Left_Neutral_Zone_Trench", Left_Neutral_Zone_Trench),
		Map.entry("Right_Neutral_Zone2", Right_Neutral_Zone2),
		Map.entry("Climb_Right", Climb_Right),
		Map.entry("Depot", Depot)
    );

    /**
     * Looks up the ChoreoTraj segment of the given overall ChoreoTraj.
     * WARNING: will raise an exception if not called with a valid segment index.
     */
    public ChoreoTraj segment(int segment) {
        var traj = ChoreoTraj.ALL_TRAJECTORIES.get(this.name + "$" + segment);
        if (traj == null) {
            throw new NullPointerException("Trajectory " + this.name + " does not have segment #" + segment + ".");
        }
        return traj;
    }
    
    // If these methods cause errors because you're not using ChoreoLib,
    // turn off "Include ChoreoLib-specific Helpers" in Choreo's codegen settings.
    /**
     * Load an AutoTrajectory directly from a ChoreoTraj, which may be a segment of a larger trajectory.
     */
    public AutoTrajectory asAutoTraj(AutoRoutine routine) {
        if (this.segment.isPresent()) {
            return routine.trajectory(this.name, this.segment.getAsInt());
        }
        return routine.trajectory(this.name);
    }
}
